<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>P2P Supabase WebRTC (Embed)</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>html,body,#app{height:100%}body{background:#0b0f16;color:#e6edf3}</style>
</head>
<body>
  <div id="app" class="min-h-screen flex items-center justify-center p-6">
    <div id="root" class="w-full max-w-3xl"></div>
  </div>

  <script type="module">
    import { createClient } from 'https://cdn.jsdelivr.net/npm/@supabase/supabase-js/+esm'

    // === CONFIG - replace these with your Supabase values ===
    const SUPABASE_URL = 'https://egotdjatiuahddtowpdo.supabase.co'
    const SUPABASE_ANON_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImVnb3RkamF0aXVhaGRkdG93cGRvIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjkwMjg0NDAsImV4cCI6MjA4NDYwNDQ0MH0.HESHFnWwDj5sbsE_m-Fe5XvgLg7NqQuJPncUfo7PsMQ'
    // =======================================================

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY)

    const STUN_CONFIG = { iceServers: [{ urls: 'stun:stun.l.google.com:19302' }] }

    // --- Simple DOM helpers ---
    const root = document.getElementById('root')

    function el(tag, props = {}, children = []) {
      const node = document.createElement(tag)
      Object.entries(props).forEach(([k, v]) => {
        if (k === 'class') node.className = v
        else if (k.startsWith('on') && typeof v === 'function') node.addEventListener(k.slice(2).toLowerCase(), v)
        else node.setAttribute(k, v)
      })
      ;(Array.isArray(children) ? children : [children]).forEach(c => {
        if (typeof c === 'string') node.appendChild(document.createTextNode(c))
        else if (c instanceof Node) node.appendChild(c)
      })
      return node
    }

    // --- App State ---
    let pc = null
    let dataChannel = null
    let channel = null
    let messages = []
    let status = 'Searching'
    let error = null

    function renderLobby() {
      root.innerHTML = ''
      const form = el('form', { class: 'p-6 bg-gray-800 rounded-md shadow-md', onsubmit: (e) => { e.preventDefault(); joinRoom(roomInput.value.trim(), nickInput.value.trim()) } })
      form.appendChild(el('h1', { class: 'text-2xl mb-4' }, 'Join a Room'))
      form.appendChild(el('label', { class: 'block mb-2 text-sm' }, 'Room Name'))
      const roomInput = el('input', { class: 'w-full p-2 mb-4 rounded bg-gray-700', placeholder: 'room-123' })
      form.appendChild(roomInput)
      form.appendChild(el('label', { class: 'block mb-2 text-sm' }, 'Nickname'))
      const nickInput = el('input', { class: 'w-full p-2 mb-4 rounded bg-gray-700', placeholder: 'Sally' })
      form.appendChild(nickInput)
      const joinBtn = el('button', { class: 'w-full bg-indigo-600 hover:bg-indigo-500 text-white p-2 rounded' }, 'Join')
      form.appendChild(joinBtn)
      root.appendChild(el('div', { class: 'flex items-center justify-center min-h-screen' }, form))
    }

    function renderRoom(roomId, nickname) {
      root.innerHTML = ''
      const container = el('div', { class: 'p-4' })
      const header = el('div', { class: 'flex justify-between items-center mb-4' })
      header.appendChild(el('div', {}, [el('div', { class: 'text-sm text-gray-400' }, 'Room'), el('div', { class: 'text-xl' }, roomId)]))
      header.appendChild(el('div', { class: 'text-right' }, [el('div', { class: 'text-sm text-gray-400' }, 'Nick'), el('div', { class: 'text-lg' }, nickname)]))
      container.appendChild(header)

      const statusDiv = el('div', { class: 'mb-4' }, [el('span', {}, 'Connection Status: '), el('strong', {}, status)])
      container.appendChild(statusDiv)
      if (error) container.appendChild(el('div', { class: 'text-red-400 mt-2' }, error))

      const msgBox = el('div', { class: 'bg-gray-800 rounded p-4 mb-4 h-80 overflow-y-auto' })
      function refreshMessages() {
        msgBox.innerHTML = ''
        messages.forEach(m => msgBox.appendChild(el('div', { class: 'mb-2' }, [el('span', { class: 'text-indigo-300 mr-2' }, m.from + ':'), el('span', {}, ' ' + m.text)])))
      }
      container.appendChild(msgBox)

      const input = el('input', { class: 'flex-1 p-2 rounded bg-gray-800', placeholder: 'Message (P2P)' })
      const sendBtn = el('button', { class: 'bg-indigo-600 px-4 rounded ml-2', onclick: () => { sendMessage(input.value); input.value = '' } }, 'Send')
      const leaveBtn = el('button', { class: 'bg-gray-700 px-4 rounded ml-2', onclick: () => leaveRoom() }, 'Leave')
      const controls = el('div', { class: 'flex gap-2' }, [input, sendBtn, leaveBtn])
      container.appendChild(controls)

      root.appendChild(container)

      // expose refresh for update
      renderRoom._refreshMessages = refreshMessages
    }

    // --- Signaling and WebRTC ---
    async function joinRoom(roomId, nickname) {
      if (!roomId || !nickname) return alert('Room and nickname required')
      messages = []
      status = 'Searching'
      error = null
      renderRoom(roomId, nickname)

      channel = supabase.channel('room:' + roomId)
      channel.on('broadcast', { event: 'signal' }, handleSignal)
      await channel.subscribe()

      // ask others to offer
      channel.send({ type: 'broadcast', event: 'signal', payload: { type: 'request-offer', from: nickname } })
      status = 'Connecting'
      renderRoom(roomId, nickname)

      // firewall timeout
      setTimeout(() => {
        if (!dataChannel || dataChannel.readyState !== 'open') {
          error = 'School Firewall Blocked P2P - Try another method.'
          status = 'Error'
          renderRoom(roomId, nickname)
        }
      }, 20000)
    }

    function sendSignal(payload) {
      if (!channel) return
      channel.send({ type: 'broadcast', event: 'signal', payload })
    }

    async function handleSignal(ev) {
      const message = ev.payload
      if (!message) return

      if (message.type === 'request-offer') {
        // someone joined, create offer
        if (!pc) await createOffer()
      }

      if (message.type === 'offer' && message.sdp) {
        await ensurePC()
        await pc.setRemoteDescription(new RTCSessionDescription(message.sdp))
        const answer = await pc.createAnswer()
        await pc.setLocalDescription(answer)
        sendSignal({ type: 'answer', sdp: pc.localDescription })
      }

      if (message.type === 'answer' && message.sdp) {
        if (pc) await pc.setRemoteDescription(new RTCSessionDescription(message.sdp))
      }

      if (message.type === 'ice' && message.candidate) {
        try { if (pc) await pc.addIceCandidate(new RTCIceCandidate(message.candidate)) } catch(e){}
      }
    }

    async function ensurePC() {
      if (pc) return
      pc = new RTCPeerConnection(STUN_CONFIG)
      pc.onicecandidate = (e) => { if (e.candidate) sendSignal({ type: 'ice', candidate: e.candidate }) }
      pc.ondatachannel = (e) => { setupDataChannel(e.channel) }
      pc.onconnectionstatechange = () => {
        if (!pc) return
        if (pc.connectionState === 'connected') { status = 'Connected'; renderCurrentRoom() }
        if (pc.connectionState === 'failed') { error = 'School Firewall Blocked P2P - Try another method.'; status = 'Error'; renderCurrentRoom() }
      }
    }

    async function createOffer() {
      await ensurePC()
      const dc = pc.createDataChannel('chat')
      setupDataChannel(dc)
      const offer = await pc.createOffer()
      await pc.setLocalDescription(offer)
      sendSignal({ type: 'offer', sdp: pc.localDescription })
    }

    function setupDataChannel(dc) {
      dataChannel = dc
      dataChannel.onopen = () => {
        status = 'Connected'
        // stop using Supabase for messaging
        if (channel) channel.unsubscribe()
        renderCurrentRoom()
      }
      dataChannel.onmessage = (e) => {
        try {
          const payload = JSON.parse(e.data)
          if (payload.type === 'chat') {
            messages.push({ from: payload.nick, text: payload.text })
            if (renderRoom._refreshMessages) renderRoom._refreshMessages()
          }
        } catch (err) {}
      }
      dataChannel.onclose = () => { status = 'Searching'; renderCurrentRoom() }
    }

    function renderCurrentRoom() {
      // attempt to re-render room using last known room/nick from the current channel name
      if (!channel) return
      const name = channel.topic || ''
      const roomId = name.replace('room:', '')
      // we don't keep nickname here, but UI doesn't strictly need it on re-render
      renderRoom(roomId, '')
      if (renderRoom._refreshMessages) renderRoom._refreshMessages()
    }

    function sendMessage(text) {
      if (!text) return
      const payload = { type: 'chat', nick: 'Peer', text, ts: Date.now() }
      if (dataChannel && dataChannel.readyState === 'open') {
        dataChannel.send(JSON.stringify(payload))
        messages.push({ from: 'You', text })
        if (renderRoom._refreshMessages) renderRoom._refreshMessages()
      } else {
        alert('Not connected P2P yet')
      }
    }

    function leaveRoom() {
      if (channel) { try { channel.unsubscribe() } catch(e){} channel = null }
      if (pc) { try { pc.close() } catch(e){} pc = null }
      dataChannel = null
      messages = []
      status = 'Searching'
      error = null
      renderLobby()
    }

    // initial render
    renderLobby()

  </script>
</body>
</html>
